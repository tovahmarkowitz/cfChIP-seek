# Python standard library
from os.path import join
from os import listdir
import os, sys, re, datetime

# 3rd party imports from pypi
from snakemake.workflow import workflow as wf_api
from snakemake.utils import R

# Local imports
from scripts.common import (
    allocated,
    provided, 
    references,
    str_bool
)

# Timestamp in YYYYMMDD format
today = str(datetime.datetime.today()).split()[0].replace('-', '')

# Global workflow variables
configfile: "config.json"
samples  = config['samples']
workpath = config['project']['workpath']
tmpdir = config['options']['tmp_dir']

# Analysis options
# Run differential binding pipeline
run_dba = True 
if config['options']['contrasts'] == 'None':
    run_dba = False

# Read in resource information,
# containing information about 
# threads, mem, walltimes, etc.
# TODO: Add handler for when the
# mode is set to local.
with open(join('config', 'cluster.json')) as fh:
    cluster = json.load(fh)

#############################
# Functions

def outputfiles2(extensions, groupslist, inputnorm):
    """
    Produces correct output filenames based on group information.
    Names will be:
    Inputnorm.Q5DD.RPGC.metagene_heatmap.pdf
    {groupName}.Q5DD.RPGC.metagene_heatmap.pdf
    {groupName}.sorted.RPGC.metagene_heatmap.pdf
    Note: Inputnorm will only be included when there are input samples.
    """
    dtoolgroups, dtoolext = [], []
    if len(inputnorm) == 2:
            dtoolgroups.extend(["InputNorm"])
            dtoolext.extend([extensions[1]])
    for group in groupslist:
            dtoolgroups.extend([group] * 2)
            dtoolext.extend([extensions[1], extensions[0]])
    if len(inputnorm) == 2:
            dtoolgroups.extend(["InputNorm.prot"])
            dtoolext.extend([extensions[1]])
    for group in groupslist:
            dtoolgroups.extend([group + ".prot"] * 2)
            dtoolext.extend([extensions[1], extensions[0]])
    return dtoolgroups, dtoolext



#############################
## Creating naming conventions for bam (and tagAlign files if SE)
# extension objects defined here are especially relevant for the deeptools rules
# and all four are used in at least one rule

se=""
pe=""
if config['project']['nends'] == 2 :
    pe="yes"
elif config['project']['nends'] == 1 :
    se="yes"

extensions = [ "sorted.RPGC", "Q5DD.RPGC" ]
extensions2 = list(map(lambda x:re.sub(".RPGC","",x),extensions))

if pe == "yes":
    extensions3 = { extensions2[i] + "." : "bam" for i in range(len(extensions2)) }
    extensions4 = [ extensions2[i] + ".bam" for i in range(len(extensions2)) ]
else:
    types = [ "bam", "tagAlign.gz" ]
    extensions3 = { extensions2[i] + "." : types[i] for i in range(len(extensions2)) }
    extensions4 = [ extensions2[i] + "." + types[i] for i in range(len(extensions2)) ]

#############################
## Getting sample relationships from config file
# using ChIP/input nomenclature, ATAC just won't have input samples

chip2input = config['project']['peaks']['inputs']
uniq_inputs = list(sorted(set([v for v in chip2input.values() if v])))

sampleswinput = []
for input in chip2input:
	if chip2input[input] != 'NA' and chip2input[input] != '':
		sampleswinput.append(input)

if len(sampleswinput) == 0:
    inputnorm = [""]
else:
    inputnorm = ["",".inputnorm"]

groupdata = config['project']['groups']

groupdatawinput = {}
for group, chips in groupdata.items() :
    tmp = [ ]
    for chip in chips :
        if chip in samples:
            tmp.append(chip)
            input = chip2input[chip]
            if input != 'NA' and input != '':
                tmp.append(input)
    if len(tmp) != 0:
        groupdatawinput[group]=set(tmp)

groups = list(groupdatawinput.keys())
deepgroups, deepexts = outputfiles2(extensions, groups,inputnorm)

#############################
# Directory names

trim_dir='trim'
kraken_dir='kraken'
bam_dir='bam'
bw_dir='bigwig'
deeptools_dir='deeptools'
extra_fingerprint_dir='deeptools/sorted_fingerprint'
qc_dir="QC"
ppqt_dir="ppqt"

#############################
# cfChIP-specific flags

cfChIP=True

# Setup to run with ChIP samples, 
# which could include IgG samples
H3K4me3samples = list(config['project']['peaks']['chips'])

cfTool_dir="cfChIPtool"
cfTool_subdir2="cfChIPtool/BED/H3K4me3"

#############################
# rule all for cfChIP

rule all:
    input: 
        # multiQC, only PE-specific ones listed here
        join(workpath,"multiqc_report.html"),
        expand(join(workpath,qc_dir,"{name}.{ext}.insert_size_metrics.txt"),name=samples,ext=extensions2),
        # Filtered bam
        expand(join(workpath,bam_dir,"{name}.{ext}"),name=samples,ext=extensions4[1]),
        # BWA --> BigWig
#        expand(join(workpath,bw_dir,"{name}.{ext}.bw",),name=samples,ext=extensions[1]),
#        expand(join(workpath,bw_dir,"{name}.Q5DD.RPGC.inputnorm.bw",),name=sampleswinput),
        # PhantomPeakQualTools
#        expand(join(workpath,ppqt_dir,"{name}.{ext}.ppqt"),name=samples,ext=extensions2),
        # deeptools
#        expand(join(workpath,deeptools_dir,"spearman_heatmap.{ext}.pdf"),ext=extensions),
#   	 expand(join(workpath,deeptools_dir,"{group}.fingerprint.{ext}.pdf"),group=groups,ext=extensions2),
#        expand(join(workpath,deeptools_dir,"{group}.metagene_heatmap.{ext}.pdf"), zip, group=deepgroups,ext=deepexts),
        # cfChIP-specific
        expand(join(workpath,cfTool_dir,"Output","H3K4me3","Signatures","{name}.Q5DD.csv"),name=H3K4me3samples),
        join(workpath,qc_dir,"H3K4me3_cfChIP_signature.txt"),



#############################
# QC rules common to all versions
include: "rules/commonQC.smk"

# QC/alignment rules common to all PE versions
include: "rules/commonPE.smk"

# QC/alignment rules specific to SE ChIP-seq
#include: "rules/commonSE.smk"

# cfChIP-specific QC rules
if cfChIP:
    include: "rules/cfChIP.smk"
